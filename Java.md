# 1 对于Java的理解
- `简单易学` ：面向对象 (封装、继承、多态)。
- `平台无关性`:在不同的操作系统有不同的实现。
- `垃圾回收机制`：内存管理机制，不需要手动释放内存，不提供指针访问内存。
- `支持多线程`
- `支持网络编程并且很方便`:运行在多个计算机上的程序，可以通过网络连接起来。
- `编译与解释共存`:JVM类加载器加载字节码文件（.class),然后通过解释器逐行执行，这种执行速度相对较慢，JIT是运行时编译，对热点代码进行编译。

## 1.1 面向对象
面向对象有三大特性L：封装、继承、多态。类一般都是 `public` ,如果不是的话，这个类也就失去意义。
### 1.1.1 封装
- `封装概念`：封装是指将函数接口的实现细节部分包装、隐藏起来的方法。
  - 一个类封装的是自己的属性和方法，不需要依赖其他类就可以完成自己的操作。
  - 可以认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。
  - 访问该类的代码和数据，必须严格的通过接口控制。
  - 可以修改自己的代码，而不用修改那些调用我们代码的函数片段。
  - 代码简洁，可读性高，安全性高。
- `封装的优势`
  - 良好的封装可以减少耦合
  - 类内部的结构可以自由修改
  - 隐藏信息，实现细节
  - 可以对成员变量进行更精准的控制
- 对每个私有属性，会创建公共方法，用于对私有属性的访问。
## 1.1.2 继承
- `原因`:多个类的代码高度重复时，代码冗余，维护性不高（维护性后期需要修改的时候，需要修改很多代码，抽取出公共的部分组成一个父类。
- `继承的特性`：
  - 子类继承父类非private的属性、方法
  - 子类拥有自己的属性和方法，可以对父类进行拓展
  - 子类可以用自己的方式实现父类的方法
  - Java的继承是单继承，不支持多继承（例，C同时继承A和B）；但是支持多重继承（B继承A，C继承B），这是Java区别于C++继承的一个特性。
  - 提高了类之间的耦合性，代码独立性差。
  - 子类不能继承父类的构造器（构造函数），只能显示或者隐式的调用，系统会自动调用无参的构造函数，对于有参的构造函数，super()关键字调用父类的构造函数并配以适当的参数列表。
- `类继承关键字`：`extends `
  - 例：`public class A extends B{}`
  - 默认继承java.lang.Object，Object这个类
- `接口继承关键字`：`implements`(接口支持多继承)
  例：`public class C implements A，B{}`
- `this关键字`：
  - 解决局部变量和全局变量同名发生的冲突。
  - 调用自己的方法
- `super关键字`:调用父类的方法
- `final关键字`:可以修饰变量（类变量，对象变量，局部变量，形参）、方法（类方法和对象方法）、类。
  - 类是一组对象的集合
  - 被定义为final的类不能被继承。例，`(public) final class 类名{类体}` ,final定义的类，其中的属性、方法不是final。
### 1.1.3 多态
### 1.1.4 接口
- 接口是抽象方法的集合，里面只有方法的定义，没有方法的实现。
- 除非类是抽象类，否则继承接口的类要实现接口中的全部方法。
- `接口与类的区别`：
  - 接口不能实例化对象
  - 接口没有构造方法
  - 接口不是被类继承，是被类实现
  - 接口支持多继承
  - 接口不能包含成员变量，除了static和final变量
- `接口特性`
  - 接口中的方法是隐式抽象的，默认是 `public abstract`
  - 接口中的变量被隐式的指定为 `public static final`
  - 接口中的方法不能在接口中实现，只能由实现接口的类中实现
  - 接口中不能有静态代码块和静态方法（用 `static` 修饰的）
  - 接口中的方法都是公有的。
  - 接口支持多继承。
- 抽象类与接口的区别：
  - 得分
  - 得分
  - 反对法
  - 佛如
- `Java8新特性`：允许接口中有默认方法的实现（用default修饰）；允许接口中有静态方法和方法体。
  - 允许有具体实现原因：当要修改一个接口时，需要修改所有实现该接口的类。
  - 一个类继承多个接口时，方法有重复时，一个是通过super指定接口，第二个是在类中重写该方法。
- `Java9新特性`：
  - dvc
- `标记接口`：
  - 没有任何方法，是为了给某个对象打上个标签。
  - 目的：建立一个公共的父接口；继承标记接口的类无需实现任何方法，可以通过多态性变成一个接口类型（这个不是太理解）。

### 1.1.5 重载和重写
- 重写：
  - 返回值和形参都不能改变。
  - 不能改变返回类型。
  - 访问权限不能比父类的权限更低。
  - 抛出异常要比父类范围更小。
  - 子类不能重新父类的private和final的方法
  - 构造方法不能被重写。

```java
class Animal{
   public void move(){
      System.out.println("动物可以移动");
   }
}
class Dog extends Animal{
   public void move(){
      System.out.println("狗可以跑和走");
   }
}
 
public class TestDog{
   public static void main(String args[]){
      Animal a = new Animal(); // Animal 对象
      Animal b = new Dog(); // Dog 对象
 
      a.move();// 执行 Animal 类的方法
 
      b.move();//执行 Dog 类的方法
   }
}
```
尽管b属于Animal类型，但是运行的是Dog的方法，这是由于在编译阶段，只是检查参数的引用类型，运行时，Java虚拟机（JVM)指定对象的类型并且运行该对象的方法。之所以能够编译成功，是因为Animal类中存在move方法，运行时，运行的是特定对象的方法。
```java
class Animal{
   public void move(){
      System.out.println("动物可以移动");
   }
}
 
class Dog extends Animal{
   public void move(){
      System.out.println("狗可以跑和走");
   }
   public void bark(){
      System.out.println("狗可以吠叫");
   }
}
 
public class TestDog{
   public static void main(String args[]){
      Animal a = new Animal(); // Animal 对象
      Animal b = new Dog(); // Dog 对象
 
      a.move();// 执行 Animal 类的方法
      b.move();//执行 Dog 类的方法
      b.bark();//编译出错
   }
}
```
这个会出现编译错误，因为b的引用类型Animal类中没有bark方法

- 重载
  - 在一个类里面，方法名字相同，参数不同（个数或者类型不同）。
  - 可以改变返回类型。
  - 可以修改访问权限。
  - 可以抛出更广泛的异常。
  - 最常用的就是构造函数的重载。
  - 仅是返回类型不同的重载是不可以的，除非编译器可以识别具体调用的是哪个函数。
- 总结
  - 方法的重载和重写是java多态性的体现
  - 重写体现的是子类与父类的多态性；重载体现的是一个类的多态性的表现
- 形象比喻
  - 厨师教徒弟做红烧肉这是继承。
  - 徒弟在师傅的基础上对红烧肉作了改良这是重写。
  - 徒弟做红烧鱼、红烧排骨这是重载。

### 1.1.6 java包

### 1.1.7 枚举

### 1.1.8 抽象类

- java中所有的对象都是通过类来描绘的，但是并不是所有的类都能描述对象，这个类就是抽象类。
- 抽象类不是空方法体，里面只是没有包含足够多的信息。
- 抽象类不能实例化对象，所以抽象类只有被继承，才能使用。
- `public abstract class Employee`
